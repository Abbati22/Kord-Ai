const EventEmitter = require('events');
const axios = require('axios');

class WordMastermind extends EventEmitter {
    constructor() {
        super();
        this.games = new Map();
        this.wordCache = {
            easy: new Set(),
            medium: new Set(),
            hard: new Set(),
            lastFetch: 0
        };
    }

    init(sock) {
        this.sock = sock;
        this.setupMessageListener();
        this.fetchWords();
    }

    setupMessageListener() {
        this.sock.ev.on('messages.upsert', ({ messages }) => {
            for (const message of messages) {
                if (message.key.fromMe) continue;
                this.handleIncomingMessage(message);
            }
        });
    }

    async handleIncomingMessage(message) {
        const chatId = message.key.remoteJid;
        const game = this.games.get(chatId);
        
        if (!game?.active || !game.players.has(message.key.participant || message.key.remoteJid)) {
            return;
        }

        const guess = (message.message?.conversation || 
                      message.message?.extendedTextMessage?.text || '').toLowerCase().trim();

        if (guess && !guess.startsWith('.')) {
            await this.processGuess(message, guess);
        }
    }

    async fetchWords() {
        try {
            if (Date.now() - this.wordCache.lastFetch < 24 * 60 * 60 * 1000 && 
                (this.wordCache.easy.size > 0 || this.wordCache.medium.size > 0)) {
                return;
            }

            const response = await axios.get('https://random-word-api.herokuapp.com/word?number=100');
            const words = response.data;

            Object.keys(this.wordCache).forEach(key => {
                if (key !== 'lastFetch') this.wordCache[key].clear();
            });

            words.forEach(word => {
                if (word.length <= 5) this.wordCache.easy.add(word.toLowerCase());
                else if (word.length <= 7) this.wordCache.medium.add(word.toLowerCase());
                else this.wordCache.hard.add(word.toLowerCase());
            });

            this.wordCache.lastFetch = Date.now();
        } catch (error) {
            console.error('Error fetching words:', error);
            this.useFallbackWords();
        }
    }

    useFallbackWords() {
        const fallback = {
            easy: ['word', 'play', 'game', 'time', 'life', 'book'],
            medium: ['player', 'master', 'random', 'simple', 'create'],
            hard: ['remember', 'complete', 'business', 'positive']
        };

        Object.entries(fallback).forEach(([key, words]) => {
            this.wordCache[key] = new Set(words);
        });
    }

    getWord(difficulty) {
        const words = Array.from(this.wordCache[difficulty] || this.wordCache.medium);
        return words[Math.floor(Math.random() * words.length)];
    }

    async handleCommand(sock, m, args) {
        const command = args[0]?.toLowerCase();
        const subCommand = args[1]?.toLowerCase();

        switch (command) {
            case 'start':
                await this.startGame(m, subCommand);
                break;
            case 'join':
                await this.joinGame(m);
                break;
            case 'hint':
                await this.giveHint(m);
                break;
            case 'status':
                await this.showStatus(m);
                break;
            case 'end':
                await this.endGame(m);
                break;
            default:
                await this.showHelp(m);
        }
    }

    async startGame(m, difficulty = 'medium') {
        const chatId = m.key.remoteJid;
        
        if (this.games.get(chatId)?.active) {
            return kord.freply(m, "❌ A game is already in progress! Use '.wm end' to finish it.");
        }

        difficulty = ['easy', 'medium', 'hard'].includes(difficulty) ? difficulty : 'medium';
        const word = this.getWord(difficulty);

        if (!word) {
            return kord.freply(m, "❌ Error starting game. Please try again.");
        }

        const game = {
            active: true,
            word,
            difficulty,
            attempts: 0,
            maxAttempts: { easy: 8, medium: 6, hard: 5 }[difficulty],
            hints: { easy: 3, medium: 2, hard: 1 }[difficulty],
            startTime: Date.now(),
            creator: m.sender,
            players: new Set([m.sender])
        };

        this.games.set(chatId, game);

        return kord.freply(m, `🎮 Word Mastermind Started!
• Difficulty: ${difficulty}
• Word length: ${word.length}
• Max attempts: ${game.maxAttempts}
• Hints: ${game.hints}

Join with '.wm join'
Then just type your guesses!`);
    }

    async joinGame(m) {
        const chatId = m.key.remoteJid;
        const game = this.games.get(chatId);

        if (!game?.active) {
            return kord.freply(m, "❌ No active game! Start one with '.wm start'");
        }

        if (game.players.has(m.sender)) {
            return kord.freply(m, "You're already in the game!");
        }

        game.players.add(m.sender);
        return kord.freply(m, `${m.pushName || 'Player'} joined! 
Players: ${game.players.size}`);
    }

    async processGuess(m, guess) {
        const chatId = m.key.remoteJid;
        const game = this.games.get(chatId);

        if (guess.length !== game.word.length) {
            return kord.freply(m, `❌ Guess must be ${game.word.length} letters!`);
        }

        game.attempts++;

        if (guess === game.word) {
            const timeTaken = Math.floor((Date.now() - game.startTime) / 1000);
            this.games.delete(chatId);
            
            return kord.freply(m, `🎉 Congratulations ${m.pushName || 'Player'}!
Word: ${game.word}
Attempts: ${game.attempts}
Time: ${timeTaken}s
Players: ${game.players.size}`);
        }

        if (game.attempts >= game.maxAttempts) {
            this.games.delete(chatId);
            return kord.freply(m, `Game Over! The word was: ${game.word}`);
        }

        let feedback = '';
        for (let i = 0; i < guess.length; i++) {
            if (game.word[i] === guess[i]) feedback += '🟩';
            else if (game.word.includes(guess[i])) feedback += '🟨';
            else feedback += '⬜';
        }

        return kord.freply(m, `Guess #${game.attempts}: ${feedback}
Attempts left: ${game.maxAttempts - game.attempts}`);
    }

    async giveHint(m) {
        const chatId = m.key.remoteJid;
        const game = this.games.get(chatId);

        if (!game?.active) {
            return kord.freply(m, "❌ No active game!");
        }

        if (!game.players.has(m.sender)) {
            return kord.freply(m, "❌ Join the game first!");
        }

        if (game.hints <= 0) {
            return kord.freply(m, "❌ No hints remaining!");
        }

        game.hints--;
        
        const revealIndex = Math.floor(Math.random() * game.word.length);
        let hint = '_'.repeat(game.word.length).split('');
        hint[revealIndex] = game.word[revealIndex];

        return kord.freply(m, `🎯 Hint (${game.hints} left): ${hint.join('')}`);
    }

    async showStatus(m) {
        const chatId = m.key.remoteJid;
        const game = this.games.get(chatId);

        if (!game?.active) {
            return kord.freply(m, "❌ No active game!");
        }

        const timePlayed = Math.floor((Date.now() - game.startTime) / 1000);

        return kord.freply(m, `📊 Game Status:
• Difficulty: ${game.difficulty}
• Word length: ${game.word.length}
• Attempts: ${game.attempts}/${game.maxAttempts}
• Hints left: ${game.hints}
• Players: ${game.players.size}
• Time: ${timePlayed}s`);
    }

    async endGame(m) {
        const chatId = m.key.remoteJid;
        const game = this.games.get(chatId);

        if (!game?.active) {
            return kord.freply(m, "❌ No active game!");
        }

        if (m.sender !== game.creator && !m.isAdmin) {
            return kord.freply(m, "❌ Only game creator or admin can end game!");
        }

        const word = game.word;
        this.games.delete(chatId);

        return kord.freply(m, `Game ended by ${m.pushName || 'Admin'}
The word was: ${word}`);
    }

    async showHelp(m) {
        return kord.freply(m, `🎮 Word Mastermind Commands:
• start [difficulty] - Start new game (easy/medium/hard)
• join - Join ongoing game
• hint - Get a hint
• status - Check game status
• end - End current game

Once joined, just type your guesses!`);
    }
}

const game = new WordMastermind();

module.exports = {
    usage: ["wordmastermind", "wm"],
    desc: "Play Word Mastermind! Guess the secret word.",
    commandType: "Game",
    isGroupOnly: true,
    isAdminOnly: false,
    isPrivateOnly: false,
    emoji: "🎮",
    
    setup(sock) {
        game.init(sock);
    },

    async execute(sock, m, args) {
        await game.handleCommand(sock, m, args);
    }
};